POST /article/default/1
{
  "author": "dhh",
  "title": "Hunting for great names in programming",
  "body": "One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.\n\n  It started with a simple refactoring. We allow people to post arbitrary URLs in [Basecamp 3](https://basecamp.com/?source=svn)’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.\n\nThe specific policy isn’t as important as the fact that this precondition was originally just part of the _Downloader_ class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.\n\nNo problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me _PrivateNetworkProtector_, which seemed like a fine choice until I considered the method names that’d work with it:\n\n- _PrivateNetworkProtector.protect\\_against\\_internal\\_ip\\_address(ip)_\n- _PrivateNetworkProtector.verify\\_ip\\_address\\_isnt\\_private(ip)_\n\nHmm. I didn’t like any of those choices. Both are a little too wordy and both include a negative. And come to think of it, I wasn’t even that thrilled with the word _Protector_. It implies something like surge protection, where it just negates the effects of an outlier input. That’s not really what’s going on here. We’re on the lookout for malicious attempts, so a better word would be more forceful. More focused on a threat, not just a risk.\n\nLet’s see what the programmer’s best friend, the thesaurus, had to offer:\n\n![](https://cdn-images-1.medium.com/max/800/1*FUboZOCmwK7__CuYBh6aHA.png)\n\nLots of possibilities there, but the one that really spoke to me was _Guard_ as in _PrivateNetworkGuard_. Nice. Now I can imagine some big burly fellow checking credentials with an attitude. Just the right image. So back to the right method name. Let’s try the two choices similar to what we had earlier:\n\n- _PrivateNetworkGuard.guard\\_against\\_internal\\_ip\\_address(url)_\n- _PrivateNetworkGuard.verify\\_ip\\_address\\_isnt\\_private(url)_\n\nHmm, neither of those are right either. I mean, you could use _guard_ again, but the double confetti of this repetition just annoyed my sensibilities. What if we thought of the _Guard_ as something like a prefilter, like _before\\_action_ in Action Controller? That’s promising:\n\n- _PrivateNetworkGuard.ensure\\_public\\_ip\\_address(url)_\n- _PrivateNetworkGuard.ensure\\_no\\_private\\_ip\\_address(url)_\n\nStill not quite right. The _ensure_ verb just doesn’t quite fit with the forceful idea of a _Guard._ It’s too meek. This isn’t a casual checking of credentials. This is IF THIS HAPPENS, I’M RAISING AN EXCEPTION AND BUSTING THE REQUEST!\n\nThat lead me to think of the programming language [Eiffel](https://en.wikipedia.org/wiki/Eiffel_%28programming_language%29) and the concept of design by contract. So I browsed the Wikipedia entry to see if I could mine it for a good word. Eiffel uses _require_ to state preconditions, which is what we’re doing here, but that also didn’t see right: _PrivateNetworkGuard.require\\_public\\_ip_. That’s more like something you’d write in a specification to tell well-meaning actors what they’re supposed to do. This wasn’t about well-meaning type, but rather the nefarious kind.\n\nSo I tried the thesaurus again, going off _ensure_ for alternatives:\n\n![](https://cdn-images-1.medium.com/max/800/1*V5sx1v3DkoI2qH0yXDGdhA.png)\n\nNo great candidates here. I mean, they’d all work, but they don’t feel quite right. And that’s really what this whole expedition is about. Not just finding something that _could_ work, but something where you go: _Yes! That’s perfect!_ How about something in the realm of _Guard_ then?\n\n![](https://cdn-images-1.medium.com/max/800/1*Oit7eXaSCJAozj-uAx1LPw.png)\n\nNope. That doesn’t do it either. But one word stood out as an idea: _Police._ The _Guard_ is _policing_ the incoming ip addresses to make sure that an internal one doesn’t slip through. That’s interesting. Let’s keep pulling on that thread:\n\n![](https://cdn-images-1.medium.com/max/800/1*RTzoaE1PQuKJdsa8ObdBVw.png)\n\n_ENFORCE!_ That’s it. Let’s try it out:\n\n- _PrivateNetworkGuard#enforce\\_public\\_ip(url)_\n- _PrivateNetworkGuard#enforce\\_no\\_private\\_ip(url)_\n\nIn some ways I like the negative version better, since it strikes to the heart of the responsibility: This is about catching those malicious URLs with private IPs more than its about vetting that something is public. Two sides of the same coin, perhaps, but still an important distinction.\n\nIn the end, though, I went with _PrivateNetworkGuard#enforce\\_public\\_ip(url)_ because I liked keeping a positive method name more than the slightly more apt negative version. Weighing those two subtle trade offs and picking the concern that mattered more.\n\nNow this might seem like a lot of effort to expend searching for a slightly better name, but it goes straight to the heart of programming with a smile. I ventured out to find a great name, not just a passable one. And besides, this whole exercise might have taken five minutes at the most. So not exactly blowing the budget, but definitely lifting my spirit. Isn’t programming great?\n\n* * *",
  "tags": ["ruby", "rails", "naming", "web"],
  "created_at": "2018-04-19T14:49:15.983056333Z",
  "updated_at": "2018-04-19T14:49:15.983056333Z"
}
