// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Components ArticleEditPage should correctly render ArticleEditPage 1`] = `
ShallowWrapper {
  "length": 1,
  Symbol(enzyme.__root__): [Circular],
  Symbol(enzyme.__unrendered__): <ArticleEditPage
    article={
        Object {
            "author": "dhh",
            "body": "One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
        
        It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
        
        The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
        
        No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
        
        ",
            "created_at": "2018-02-28T14:48:54.444740278Z",
            "id": "123",
            "title": "Hunting for great names in programming",
          }
    }
/>,
  Symbol(enzyme.__renderer__): Object {
    "batchedUpdates": [Function],
    "getNode": [Function],
    "render": [Function],
    "simulateEvent": [Function],
    "unmount": [Function],
  },
  Symbol(enzyme.__node__): Object {
    "instance": null,
    "key": undefined,
    "nodeType": "host",
    "props": Object {
      "children": Array [
        <Header
          resourceTitle="Hunting for great names in programming"
/>,
        <div
          className="container"
>
          <Form
                    onSubmit={[Function]}
                    tag="form"
          >
                    <div
                              className="row"
                    >
                              <div
                                        className="col"
                              >
                                        <FormGroup
                                                  tag="div"
                                        >
                                                  <Input
                                                            name="title"
                                                            onChange={[Function]}
                                                            placeholder="Title"
                                                            type="text"
                                                            value="Hunting for great names in programming"
                                                  />
                                        </FormGroup>
                                        <FormGroup
                                                  tag="div"
                                        >
                                                  <Input
                                                            name="body"
                                                            onChange={[Function]}
                                                            placeholder="Add your article"
                                                            rows="20"
                                                            type="textarea"
                                                            value="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                                                  
                                                  It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                                                  
                                                  The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                                                  
                                                  No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                                                  
                                                  "
                                                  />
                                        </FormGroup>
                              </div>
                              <div
                                        className="col"
                              >
                                        <Button
                                                  className="float-right"
                                                  color="primary"
                                                  size="lg"
                                                  tag="button"
                                        >
                                                  Save
                                        </Button>
                                        <h2>
                                                  Hunting for great names in programming
                                        </h2>
                                        <hr />
                                        <ReactMarkdown
                                                  escapeHtml={true}
                                                  renderers={Object {}}
                                                  skipHtml={false}
                                                  source="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                                        
                                        It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                                        
                                        The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                                        
                                        No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                                        
                                        "
                                                  transformLinkUri={[Function]}
                                        />
                              </div>
                    </div>
          </Form>
</div>,
      ],
    },
    "ref": null,
    "rendered": Array [
      Object {
        "instance": null,
        "key": undefined,
        "nodeType": "class",
        "props": Object {
          "resourceTitle": "Hunting for great names in programming",
        },
        "ref": null,
        "rendered": null,
        "type": [Function],
      },
      Object {
        "instance": null,
        "key": undefined,
        "nodeType": "host",
        "props": Object {
          "children": <Form
            onSubmit={[Function]}
            tag="form"
>
            <div
                        className="row"
            >
                        <div
                                    className="col"
                        >
                                    <FormGroup
                                                tag="div"
                                    >
                                                <Input
                                                            name="title"
                                                            onChange={[Function]}
                                                            placeholder="Title"
                                                            type="text"
                                                            value="Hunting for great names in programming"
                                                />
                                    </FormGroup>
                                    <FormGroup
                                                tag="div"
                                    >
                                                <Input
                                                            name="body"
                                                            onChange={[Function]}
                                                            placeholder="Add your article"
                                                            rows="20"
                                                            type="textarea"
                                                            value="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                                                
                                                It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                                                
                                                The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                                                
                                                No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                                                
                                                "
                                                />
                                    </FormGroup>
                        </div>
                        <div
                                    className="col"
                        >
                                    <Button
                                                className="float-right"
                                                color="primary"
                                                size="lg"
                                                tag="button"
                                    >
                                                Save
                                    </Button>
                                    <h2>
                                                Hunting for great names in programming
                                    </h2>
                                    <hr />
                                    <ReactMarkdown
                                                escapeHtml={true}
                                                renderers={Object {}}
                                                skipHtml={false}
                                                source="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                                    
                                    It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                                    
                                    The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                                    
                                    No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                                    
                                    "
                                                transformLinkUri={[Function]}
                                    />
                        </div>
            </div>
</Form>,
          "className": "container",
        },
        "ref": null,
        "rendered": Object {
          "instance": null,
          "key": undefined,
          "nodeType": "function",
          "props": Object {
            "children": <div
              className="row"
>
              <div
                            className="col"
              >
                            <FormGroup
                                          tag="div"
                            >
                                          <Input
                                                        name="title"
                                                        onChange={[Function]}
                                                        placeholder="Title"
                                                        type="text"
                                                        value="Hunting for great names in programming"
                                          />
                            </FormGroup>
                            <FormGroup
                                          tag="div"
                            >
                                          <Input
                                                        name="body"
                                                        onChange={[Function]}
                                                        placeholder="Add your article"
                                                        rows="20"
                                                        type="textarea"
                                                        value="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                                          
                                          It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                                          
                                          The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                                          
                                          No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                                          
                                          "
                                          />
                            </FormGroup>
              </div>
              <div
                            className="col"
              >
                            <Button
                                          className="float-right"
                                          color="primary"
                                          size="lg"
                                          tag="button"
                            >
                                          Save
                            </Button>
                            <h2>
                                          Hunting for great names in programming
                            </h2>
                            <hr />
                            <ReactMarkdown
                                          escapeHtml={true}
                                          renderers={Object {}}
                                          skipHtml={false}
                                          source="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                            
                            It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                            
                            The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                            
                            No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                            
                            "
                                          transformLinkUri={[Function]}
                            />
              </div>
</div>,
            "onSubmit": [Function],
            "tag": "form",
          },
          "ref": null,
          "rendered": Object {
            "instance": null,
            "key": undefined,
            "nodeType": "host",
            "props": Object {
              "children": Array [
                <div
                  className="col"
>
                  <FormGroup
                                    tag="div"
                  >
                                    <Input
                                                      name="title"
                                                      onChange={[Function]}
                                                      placeholder="Title"
                                                      type="text"
                                                      value="Hunting for great names in programming"
                                    />
                  </FormGroup>
                  <FormGroup
                                    tag="div"
                  >
                                    <Input
                                                      name="body"
                                                      onChange={[Function]}
                                                      placeholder="Add your article"
                                                      rows="20"
                                                      type="textarea"
                                                      value="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                                    
                                    It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                                    
                                    The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                                    
                                    No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                                    
                                    "
                                    />
                  </FormGroup>
</div>,
                <div
                  className="col"
>
                  <Button
                                    className="float-right"
                                    color="primary"
                                    size="lg"
                                    tag="button"
                  >
                                    Save
                  </Button>
                  <h2>
                                    Hunting for great names in programming
                  </h2>
                  <hr />
                  <ReactMarkdown
                                    escapeHtml={true}
                                    renderers={Object {}}
                                    skipHtml={false}
                                    source="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                  
                  It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                  
                  The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                  
                  No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                  
                  "
                                    transformLinkUri={[Function]}
                  />
</div>,
              ],
              "className": "row",
            },
            "ref": null,
            "rendered": Array [
              Object {
                "instance": null,
                "key": undefined,
                "nodeType": "host",
                "props": Object {
                  "children": Array [
                    <FormGroup
                      tag="div"
>
                      <Input
                                            name="title"
                                            onChange={[Function]}
                                            placeholder="Title"
                                            type="text"
                                            value="Hunting for great names in programming"
                      />
</FormGroup>,
                    <FormGroup
                      tag="div"
>
                      <Input
                                            name="body"
                                            onChange={[Function]}
                                            placeholder="Add your article"
                                            rows="20"
                                            type="textarea"
                                            value="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                      
                      It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                      
                      The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                      
                      No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                      
                      "
                      />
</FormGroup>,
                  ],
                  "className": "col",
                },
                "ref": null,
                "rendered": Array [
                  Object {
                    "instance": null,
                    "key": undefined,
                    "nodeType": "function",
                    "props": Object {
                      "children": <Input
                        name="title"
                        onChange={[Function]}
                        placeholder="Title"
                        type="text"
                        value="Hunting for great names in programming"
/>,
                      "tag": "div",
                    },
                    "ref": null,
                    "rendered": Object {
                      "instance": null,
                      "key": undefined,
                      "nodeType": "class",
                      "props": Object {
                        "name": "title",
                        "onChange": [Function],
                        "placeholder": "Title",
                        "type": "text",
                        "value": "Hunting for great names in programming",
                      },
                      "ref": null,
                      "rendered": null,
                      "type": [Function],
                    },
                    "type": [Function],
                  },
                  Object {
                    "instance": null,
                    "key": undefined,
                    "nodeType": "function",
                    "props": Object {
                      "children": <Input
                        name="body"
                        onChange={[Function]}
                        placeholder="Add your article"
                        rows="20"
                        type="textarea"
                        value="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.

It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.

The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.

No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:

"
/>,
                      "tag": "div",
                    },
                    "ref": null,
                    "rendered": Object {
                      "instance": null,
                      "key": undefined,
                      "nodeType": "class",
                      "props": Object {
                        "name": "body",
                        "onChange": [Function],
                        "placeholder": "Add your article",
                        "rows": "20",
                        "type": "textarea",
                        "value": "One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.

It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.

The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.

No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:

",
                      },
                      "ref": null,
                      "rendered": null,
                      "type": [Function],
                    },
                    "type": [Function],
                  },
                ],
                "type": "div",
              },
              Object {
                "instance": null,
                "key": undefined,
                "nodeType": "host",
                "props": Object {
                  "children": Array [
                    <Button
                      className="float-right"
                      color="primary"
                      size="lg"
                      tag="button"
>
                      Save
</Button>,
                    <h2>
                      Hunting for great names in programming
</h2>,
                    <hr />,
                    <ReactMarkdown
                      escapeHtml={true}
                      renderers={Object {}}
                      skipHtml={false}
                      source="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.

It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.

The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.

No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:

"
                      transformLinkUri={[Function]}
/>,
                  ],
                  "className": "col",
                },
                "ref": null,
                "rendered": Array [
                  Object {
                    "instance": null,
                    "key": undefined,
                    "nodeType": "class",
                    "props": Object {
                      "children": "Save",
                      "className": "float-right",
                      "color": "primary",
                      "size": "lg",
                      "tag": "button",
                    },
                    "ref": null,
                    "rendered": "Save",
                    "type": [Function],
                  },
                  Object {
                    "instance": null,
                    "key": undefined,
                    "nodeType": "host",
                    "props": Object {
                      "children": "Hunting for great names in programming",
                    },
                    "ref": null,
                    "rendered": "Hunting for great names in programming",
                    "type": "h2",
                  },
                  Object {
                    "instance": null,
                    "key": undefined,
                    "nodeType": "host",
                    "props": Object {},
                    "ref": null,
                    "rendered": null,
                    "type": "hr",
                  },
                  Object {
                    "instance": null,
                    "key": undefined,
                    "nodeType": "function",
                    "props": Object {
                      "escapeHtml": true,
                      "renderers": Object {},
                      "skipHtml": false,
                      "source": "One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.

It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.

The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.

No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:

",
                      "transformLinkUri": [Function],
                    },
                    "ref": null,
                    "rendered": null,
                    "type": [Function],
                  },
                ],
                "type": "div",
              },
            ],
            "type": "div",
          },
          "type": [Function],
        },
        "type": "div",
      },
    ],
    "type": "div",
  },
  Symbol(enzyme.__nodes__): Array [
    Object {
      "instance": null,
      "key": undefined,
      "nodeType": "host",
      "props": Object {
        "children": Array [
          <Header
            resourceTitle="Hunting for great names in programming"
/>,
          <div
            className="container"
>
            <Form
                        onSubmit={[Function]}
                        tag="form"
            >
                        <div
                                    className="row"
                        >
                                    <div
                                                className="col"
                                    >
                                                <FormGroup
                                                            tag="div"
                                                >
                                                            <Input
                                                                        name="title"
                                                                        onChange={[Function]}
                                                                        placeholder="Title"
                                                                        type="text"
                                                                        value="Hunting for great names in programming"
                                                            />
                                                </FormGroup>
                                                <FormGroup
                                                            tag="div"
                                                >
                                                            <Input
                                                                        name="body"
                                                                        onChange={[Function]}
                                                                        placeholder="Add your article"
                                                                        rows="20"
                                                                        type="textarea"
                                                                        value="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                                                            
                                                            It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                                                            
                                                            The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                                                            
                                                            No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                                                            
                                                            "
                                                            />
                                                </FormGroup>
                                    </div>
                                    <div
                                                className="col"
                                    >
                                                <Button
                                                            className="float-right"
                                                            color="primary"
                                                            size="lg"
                                                            tag="button"
                                                >
                                                            Save
                                                </Button>
                                                <h2>
                                                            Hunting for great names in programming
                                                </h2>
                                                <hr />
                                                <ReactMarkdown
                                                            escapeHtml={true}
                                                            renderers={Object {}}
                                                            skipHtml={false}
                                                            source="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                                                
                                                It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                                                
                                                The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                                                
                                                No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                                                
                                                "
                                                            transformLinkUri={[Function]}
                                                />
                                    </div>
                        </div>
            </Form>
</div>,
        ],
      },
      "ref": null,
      "rendered": Array [
        Object {
          "instance": null,
          "key": undefined,
          "nodeType": "class",
          "props": Object {
            "resourceTitle": "Hunting for great names in programming",
          },
          "ref": null,
          "rendered": null,
          "type": [Function],
        },
        Object {
          "instance": null,
          "key": undefined,
          "nodeType": "host",
          "props": Object {
            "children": <Form
              onSubmit={[Function]}
              tag="form"
>
              <div
                            className="row"
              >
                            <div
                                          className="col"
                            >
                                          <FormGroup
                                                        tag="div"
                                          >
                                                        <Input
                                                                      name="title"
                                                                      onChange={[Function]}
                                                                      placeholder="Title"
                                                                      type="text"
                                                                      value="Hunting for great names in programming"
                                                        />
                                          </FormGroup>
                                          <FormGroup
                                                        tag="div"
                                          >
                                                        <Input
                                                                      name="body"
                                                                      onChange={[Function]}
                                                                      placeholder="Add your article"
                                                                      rows="20"
                                                                      type="textarea"
                                                                      value="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                                                        
                                                        It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                                                        
                                                        The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                                                        
                                                        No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                                                        
                                                        "
                                                        />
                                          </FormGroup>
                            </div>
                            <div
                                          className="col"
                            >
                                          <Button
                                                        className="float-right"
                                                        color="primary"
                                                        size="lg"
                                                        tag="button"
                                          >
                                                        Save
                                          </Button>
                                          <h2>
                                                        Hunting for great names in programming
                                          </h2>
                                          <hr />
                                          <ReactMarkdown
                                                        escapeHtml={true}
                                                        renderers={Object {}}
                                                        skipHtml={false}
                                                        source="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                                          
                                          It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                                          
                                          The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                                          
                                          No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                                          
                                          "
                                                        transformLinkUri={[Function]}
                                          />
                            </div>
              </div>
</Form>,
            "className": "container",
          },
          "ref": null,
          "rendered": Object {
            "instance": null,
            "key": undefined,
            "nodeType": "function",
            "props": Object {
              "children": <div
                className="row"
>
                <div
                                className="col"
                >
                                <FormGroup
                                                tag="div"
                                >
                                                <Input
                                                                name="title"
                                                                onChange={[Function]}
                                                                placeholder="Title"
                                                                type="text"
                                                                value="Hunting for great names in programming"
                                                />
                                </FormGroup>
                                <FormGroup
                                                tag="div"
                                >
                                                <Input
                                                                name="body"
                                                                onChange={[Function]}
                                                                placeholder="Add your article"
                                                                rows="20"
                                                                type="textarea"
                                                                value="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                                                
                                                It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                                                
                                                The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                                                
                                                No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                                                
                                                "
                                                />
                                </FormGroup>
                </div>
                <div
                                className="col"
                >
                                <Button
                                                className="float-right"
                                                color="primary"
                                                size="lg"
                                                tag="button"
                                >
                                                Save
                                </Button>
                                <h2>
                                                Hunting for great names in programming
                                </h2>
                                <hr />
                                <ReactMarkdown
                                                escapeHtml={true}
                                                renderers={Object {}}
                                                skipHtml={false}
                                                source="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                                
                                It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                                
                                The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                                
                                No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                                
                                "
                                                transformLinkUri={[Function]}
                                />
                </div>
</div>,
              "onSubmit": [Function],
              "tag": "form",
            },
            "ref": null,
            "rendered": Object {
              "instance": null,
              "key": undefined,
              "nodeType": "host",
              "props": Object {
                "children": Array [
                  <div
                    className="col"
>
                    <FormGroup
                                        tag="div"
                    >
                                        <Input
                                                            name="title"
                                                            onChange={[Function]}
                                                            placeholder="Title"
                                                            type="text"
                                                            value="Hunting for great names in programming"
                                        />
                    </FormGroup>
                    <FormGroup
                                        tag="div"
                    >
                                        <Input
                                                            name="body"
                                                            onChange={[Function]}
                                                            placeholder="Add your article"
                                                            rows="20"
                                                            type="textarea"
                                                            value="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                                        
                                        It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                                        
                                        The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                                        
                                        No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                                        
                                        "
                                        />
                    </FormGroup>
</div>,
                  <div
                    className="col"
>
                    <Button
                                        className="float-right"
                                        color="primary"
                                        size="lg"
                                        tag="button"
                    >
                                        Save
                    </Button>
                    <h2>
                                        Hunting for great names in programming
                    </h2>
                    <hr />
                    <ReactMarkdown
                                        escapeHtml={true}
                                        renderers={Object {}}
                                        skipHtml={false}
                                        source="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                    
                    It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                    
                    The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                    
                    No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                    
                    "
                                        transformLinkUri={[Function]}
                    />
</div>,
                ],
                "className": "row",
              },
              "ref": null,
              "rendered": Array [
                Object {
                  "instance": null,
                  "key": undefined,
                  "nodeType": "host",
                  "props": Object {
                    "children": Array [
                      <FormGroup
                        tag="div"
>
                        <Input
                                                name="title"
                                                onChange={[Function]}
                                                placeholder="Title"
                                                type="text"
                                                value="Hunting for great names in programming"
                        />
</FormGroup>,
                      <FormGroup
                        tag="div"
>
                        <Input
                                                name="body"
                                                onChange={[Function]}
                                                placeholder="Add your article"
                                                rows="20"
                                                type="textarea"
                                                value="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.
                        
                        It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.
                        
                        The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.
                        
                        No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:
                        
                        "
                        />
</FormGroup>,
                    ],
                    "className": "col",
                  },
                  "ref": null,
                  "rendered": Array [
                    Object {
                      "instance": null,
                      "key": undefined,
                      "nodeType": "function",
                      "props": Object {
                        "children": <Input
                          name="title"
                          onChange={[Function]}
                          placeholder="Title"
                          type="text"
                          value="Hunting for great names in programming"
/>,
                        "tag": "div",
                      },
                      "ref": null,
                      "rendered": Object {
                        "instance": null,
                        "key": undefined,
                        "nodeType": "class",
                        "props": Object {
                          "name": "title",
                          "onChange": [Function],
                          "placeholder": "Title",
                          "type": "text",
                          "value": "Hunting for great names in programming",
                        },
                        "ref": null,
                        "rendered": null,
                        "type": [Function],
                      },
                      "type": [Function],
                    },
                    Object {
                      "instance": null,
                      "key": undefined,
                      "nodeType": "function",
                      "props": Object {
                        "children": <Input
                          name="body"
                          onChange={[Function]}
                          placeholder="Add your article"
                          rows="20"
                          type="textarea"
                          value="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.

It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.

The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.

No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:

"
/>,
                        "tag": "div",
                      },
                      "ref": null,
                      "rendered": Object {
                        "instance": null,
                        "key": undefined,
                        "nodeType": "class",
                        "props": Object {
                          "name": "body",
                          "onChange": [Function],
                          "placeholder": "Add your article",
                          "rows": "20",
                          "type": "textarea",
                          "value": "One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.

It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.

The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.

No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:

",
                        },
                        "ref": null,
                        "rendered": null,
                        "type": [Function],
                      },
                      "type": [Function],
                    },
                  ],
                  "type": "div",
                },
                Object {
                  "instance": null,
                  "key": undefined,
                  "nodeType": "host",
                  "props": Object {
                    "children": Array [
                      <Button
                        className="float-right"
                        color="primary"
                        size="lg"
                        tag="button"
>
                        Save
</Button>,
                      <h2>
                        Hunting for great names in programming
</h2>,
                      <hr />,
                      <ReactMarkdown
                        escapeHtml={true}
                        renderers={Object {}}
                        skipHtml={false}
                        source="One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.

It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.

The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.

No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:

"
                        transformLinkUri={[Function]}
/>,
                    ],
                    "className": "col",
                  },
                  "ref": null,
                  "rendered": Array [
                    Object {
                      "instance": null,
                      "key": undefined,
                      "nodeType": "class",
                      "props": Object {
                        "children": "Save",
                        "className": "float-right",
                        "color": "primary",
                        "size": "lg",
                        "tag": "button",
                      },
                      "ref": null,
                      "rendered": "Save",
                      "type": [Function],
                    },
                    Object {
                      "instance": null,
                      "key": undefined,
                      "nodeType": "host",
                      "props": Object {
                        "children": "Hunting for great names in programming",
                      },
                      "ref": null,
                      "rendered": "Hunting for great names in programming",
                      "type": "h2",
                    },
                    Object {
                      "instance": null,
                      "key": undefined,
                      "nodeType": "host",
                      "props": Object {},
                      "ref": null,
                      "rendered": null,
                      "type": "hr",
                    },
                    Object {
                      "instance": null,
                      "key": undefined,
                      "nodeType": "function",
                      "props": Object {
                        "escapeHtml": true,
                        "renderers": Object {},
                        "skipHtml": false,
                        "source": "One of the real delights of programming is picking great variable, method, and class names. But an even greater treat is when you can name pairs, or even whole narratives, that fit just right. And the very best of those is when you’re forced to trade off multiple forces pulling in different directions. This is the story of one such case.

It started with a simple refactoring. We allow people to post arbitrary URLs in Basecamp 3’s chat, which we’ll attempt to fetch and display inline, if its an image, movie, or a Twitter URL. There’s a security concern where we don’t want to allow internal IPs in those URLs, like 127.0.0.1, and then have our Downloader class attempt to trigger an internal request that may sidestep other security precautions.

The specific policy isn’t as important as the fact that this precondition was originally just part of the Downloader class, but now I also needed it in our forthcoming webhooks API. Because just like with previewable chat URLs, webhooks allow users to set URLs that our system then calls. Same underlying security issue to deal with.

No problemo: Just extract the protection into its own module and call it from both spots. First attempt at naming this new module gave me PrivateNetworkProtector, which seemed like a fine choice until I considered the method names that’d work with it:

",
                        "transformLinkUri": [Function],
                      },
                      "ref": null,
                      "rendered": null,
                      "type": [Function],
                    },
                  ],
                  "type": "div",
                },
              ],
              "type": "div",
            },
            "type": [Function],
          },
          "type": "div",
        },
      ],
      "type": "div",
    },
  ],
  Symbol(enzyme.__options__): Object {
    "adapter": ReactSixteenAdapter {
      "options": Object {
        "enableComponentDidUpdateOnSetState": true,
      },
    },
  },
}
`;
